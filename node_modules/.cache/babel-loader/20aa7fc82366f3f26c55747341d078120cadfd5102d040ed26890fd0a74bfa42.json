{"ast":null,"code":"'use strict';\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n  constructor(opts) {\n    var _a;\n    this.width = opts.width;\n    this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n    this.rows = [];\n  }\n  span() {\n    const cols = this.div(...arguments);\n    cols.span = true;\n  }\n  resetOutput() {\n    this.rows = [];\n  }\n  div() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === 0) {\n      this.div('');\n    }\n    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n      return this.applyLayoutDSL(args[0]);\n    }\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this.colFromString(arg);\n      }\n      return arg;\n    });\n    this.rows.push(cols);\n    return cols;\n  }\n  shouldApplyLayoutDSL() {\n    return arguments.length === 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string' && /[\\t\\n]/.test(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n  applyLayoutDSL(str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'));\n    let leftColumnWidth = 0;\n    // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n    rows.forEach(columns => {\n      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n      }\n    });\n    // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this.measurePadding(r),\n          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n        };\n      }));\n    });\n    return this.rows[this.rows.length - 1];\n  }\n  colFromString(text) {\n    return {\n      text,\n      padding: this.measurePadding(text)\n    };\n  }\n  measurePadding(str) {\n    // measure padding without ansi escape codes\n    const noAnsi = mixin.stripAnsi(str);\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n  }\n  toString() {\n    const lines = [];\n    this.rows.forEach(row => {\n      this.rowToString(row, lines);\n    });\n    // don't display any lines with the\n    // hidden flag set.\n    return lines.filter(line => !line.hidden).map(line => line.text).join('\\n');\n  }\n  rowToString(row, lines) {\n    this.rasterize(row).forEach((rrow, r) => {\n      let str = '';\n      rrow.forEach((col, c) => {\n        const {\n          width\n        } = row[c]; // the width with padding.\n        const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n        let ts = col; // temporary string used during alignment/padding.\n        if (wrapWidth > mixin.stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n        }\n        // align the string within its column.\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          const fn = align[row[c].align];\n          ts = fn(ts, wrapWidth);\n          if (mixin.stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n          }\n        }\n        // apply border and padding to string.\n        const padding = row[c].padding || [0, 0, 0, 0];\n        if (padding[left]) {\n          str += ' '.repeat(padding[left]);\n        }\n        str += addBorder(row[c], ts, '| ');\n        str += ts;\n        str += addBorder(row[c], ts, ' |');\n        if (padding[right]) {\n          str += ' '.repeat(padding[right]);\n        }\n        // if prior row is span, try to render the\n        // current row on the prior line.\n        if (r === 0 && lines.length > 0) {\n          str = this.renderInline(str, lines[lines.length - 1]);\n        }\n      });\n      // remove trailing whitespace.\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      });\n    });\n    return lines;\n  }\n  // if the full 'source' can render in\n  // the target line, do so.\n  renderInline(source, previousLine) {\n    const match = source.match(/^ */);\n    const leadingWhitespace = match ? match[0].length : 0;\n    const target = previousLine.text;\n    const targetTextWidth = mixin.stringWidth(target.trimRight());\n    if (!previousLine.span) {\n      return source;\n    }\n    // if we're not applying wrapping logic,\n    // just always append to the span.\n    if (!this.wrap) {\n      previousLine.hidden = true;\n      return target + source;\n    }\n    if (leadingWhitespace < targetTextWidth) {\n      return source;\n    }\n    previousLine.hidden = true;\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n  }\n  rasterize(row) {\n    const rrows = [];\n    const widths = this.columnWidths(row);\n    let wrapped;\n    // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c];\n      if (this.wrap) {\n        wrapped = mixin.wrap(col.text, this.negatePadding(col), {\n          hard: true\n        }).split('\\n');\n      } else {\n        wrapped = col.text.split('\\n');\n      }\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n        wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n      }\n      // add top and bottom padding.\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n      }\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([]);\n        }\n        const rrow = rrows[r];\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('');\n          }\n        }\n        rrow.push(str);\n      });\n    });\n    return rrows;\n  }\n  negatePadding(col) {\n    let wrapWidth = col.width || 0;\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n    }\n    if (col.border) {\n      wrapWidth -= 4;\n    }\n    return wrapWidth;\n  }\n  columnWidths(row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || mixin.stringWidth(col.text);\n      });\n    }\n    let unset = row.length;\n    let remainingWidth = this.width;\n    // column widths can be set in config.\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--;\n        remainingWidth -= col.width;\n        return col.width;\n      }\n      return undefined;\n    });\n    // any unset widths should be calculated.\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]));\n      }\n      return w;\n    });\n  }\n}\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n    return '  ';\n  }\n  return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n  const padding = col.padding || [];\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n  if (col.border) {\n    return minWidth + 4;\n  }\n  return minWidth;\n}\nfunction getWindowWidth() {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n  return 80;\n}\nfunction alignRight(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n  return str;\n}\nfunction alignCenter(str, width) {\n  str = str.trim();\n  const strWidth = mixin.stringWidth(str);\n  /* istanbul ignore next */\n  if (strWidth >= width) {\n    return str;\n  }\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\nlet mixin;\nexport function cliui(opts, _mixin) {\n  mixin = _mixin;\n  return new UI({\n    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n  });\n}","map":{"version":3,"names":["align","right","alignRight","center","alignCenter","top","bottom","left","UI","constructor","opts","_a","width","wrap","rows","span","cols","div","arguments","resetOutput","_len","length","args","Array","_key","shouldApplyLayoutDSL","applyLayoutDSL","map","arg","colFromString","push","undefined","test","str","split","row","leftColumnWidth","forEach","columns","mixin","stringWidth","Math","min","floor","r","i","text","trim","padding","measurePadding","noAnsi","stripAnsi","match","toString","lines","rowToString","filter","line","hidden","join","rasterize","rrow","col","c","wrapWidth","negatePadding","ts","repeat","fn","addBorder","renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimRight","trimLeft","rrows","widths","columnWidths","wrapped","hard","border","unshift","fill","unset","remainingWidth","unsetWidth","w","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","cliui","_mixin"],"sources":["/Users/lucasfrotabarroso/Desktop/util/react-algoritmo/node_modules/cliui/build/lib/index.js"],"sourcesContent":["'use strict';\nconst align = {\n    right: alignRight,\n    center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\nexport class UI {\n    constructor(opts) {\n        var _a;\n        this.width = opts.width;\n        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;\n        this.rows = [];\n    }\n    span(...args) {\n        const cols = this.div(...args);\n        cols.span = true;\n    }\n    resetOutput() {\n        this.rows = [];\n    }\n    div(...args) {\n        if (args.length === 0) {\n            this.div('');\n        }\n        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {\n            return this.applyLayoutDSL(args[0]);\n        }\n        const cols = args.map(arg => {\n            if (typeof arg === 'string') {\n                return this.colFromString(arg);\n            }\n            return arg;\n        });\n        this.rows.push(cols);\n        return cols;\n    }\n    shouldApplyLayoutDSL(...args) {\n        return args.length === 1 && typeof args[0] === 'string' &&\n            /[\\t\\n]/.test(args[0]);\n    }\n    applyLayoutDSL(str) {\n        const rows = str.split('\\n').map(row => row.split('\\t'));\n        let leftColumnWidth = 0;\n        // simple heuristic for layout, make sure the\n        // second column lines up along the left-hand.\n        // don't allow the first column to take up more\n        // than 50% of the screen.\n        rows.forEach(columns => {\n            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {\n                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));\n            }\n        });\n        // generate a table:\n        //  replacing ' ' with padding calculations.\n        //  using the algorithmically generated width.\n        rows.forEach(columns => {\n            this.div(...columns.map((r, i) => {\n                return {\n                    text: r.trim(),\n                    padding: this.measurePadding(r),\n                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n                };\n            }));\n        });\n        return this.rows[this.rows.length - 1];\n    }\n    colFromString(text) {\n        return {\n            text,\n            padding: this.measurePadding(text)\n        };\n    }\n    measurePadding(str) {\n        // measure padding without ansi escape codes\n        const noAnsi = mixin.stripAnsi(str);\n        return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n    }\n    toString() {\n        const lines = [];\n        this.rows.forEach(row => {\n            this.rowToString(row, lines);\n        });\n        // don't display any lines with the\n        // hidden flag set.\n        return lines\n            .filter(line => !line.hidden)\n            .map(line => line.text)\n            .join('\\n');\n    }\n    rowToString(row, lines) {\n        this.rasterize(row).forEach((rrow, r) => {\n            let str = '';\n            rrow.forEach((col, c) => {\n                const { width } = row[c]; // the width with padding.\n                const wrapWidth = this.negatePadding(row[c]); // the width without padding.\n                let ts = col; // temporary string used during alignment/padding.\n                if (wrapWidth > mixin.stringWidth(col)) {\n                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));\n                }\n                // align the string within its column.\n                if (row[c].align && row[c].align !== 'left' && this.wrap) {\n                    const fn = align[row[c].align];\n                    ts = fn(ts, wrapWidth);\n                    if (mixin.stringWidth(ts) < wrapWidth) {\n                        ts += ' '.repeat((width || 0) - mixin.stringWidth(ts) - 1);\n                    }\n                }\n                // apply border and padding to string.\n                const padding = row[c].padding || [0, 0, 0, 0];\n                if (padding[left]) {\n                    str += ' '.repeat(padding[left]);\n                }\n                str += addBorder(row[c], ts, '| ');\n                str += ts;\n                str += addBorder(row[c], ts, ' |');\n                if (padding[right]) {\n                    str += ' '.repeat(padding[right]);\n                }\n                // if prior row is span, try to render the\n                // current row on the prior line.\n                if (r === 0 && lines.length > 0) {\n                    str = this.renderInline(str, lines[lines.length - 1]);\n                }\n            });\n            // remove trailing whitespace.\n            lines.push({\n                text: str.replace(/ +$/, ''),\n                span: row.span\n            });\n        });\n        return lines;\n    }\n    // if the full 'source' can render in\n    // the target line, do so.\n    renderInline(source, previousLine) {\n        const match = source.match(/^ */);\n        const leadingWhitespace = match ? match[0].length : 0;\n        const target = previousLine.text;\n        const targetTextWidth = mixin.stringWidth(target.trimRight());\n        if (!previousLine.span) {\n            return source;\n        }\n        // if we're not applying wrapping logic,\n        // just always append to the span.\n        if (!this.wrap) {\n            previousLine.hidden = true;\n            return target + source;\n        }\n        if (leadingWhitespace < targetTextWidth) {\n            return source;\n        }\n        previousLine.hidden = true;\n        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n    }\n    rasterize(row) {\n        const rrows = [];\n        const widths = this.columnWidths(row);\n        let wrapped;\n        // word wrap all columns, and create\n        // a data-structure that is easy to rasterize.\n        row.forEach((col, c) => {\n            // leave room for left and right padding.\n            col.width = widths[c];\n            if (this.wrap) {\n                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\\n');\n            }\n            else {\n                wrapped = col.text.split('\\n');\n            }\n            if (col.border) {\n                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');\n                wrapped.push(\"'\" + '-'.repeat(this.negatePadding(col) + 2) + \"'\");\n            }\n            // add top and bottom padding.\n            if (col.padding) {\n                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n            }\n            wrapped.forEach((str, r) => {\n                if (!rrows[r]) {\n                    rrows.push([]);\n                }\n                const rrow = rrows[r];\n                for (let i = 0; i < c; i++) {\n                    if (rrow[i] === undefined) {\n                        rrow.push('');\n                    }\n                }\n                rrow.push(str);\n            });\n        });\n        return rrows;\n    }\n    negatePadding(col) {\n        let wrapWidth = col.width || 0;\n        if (col.padding) {\n            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n        }\n        if (col.border) {\n            wrapWidth -= 4;\n        }\n        return wrapWidth;\n    }\n    columnWidths(row) {\n        if (!this.wrap) {\n            return row.map(col => {\n                return col.width || mixin.stringWidth(col.text);\n            });\n        }\n        let unset = row.length;\n        let remainingWidth = this.width;\n        // column widths can be set in config.\n        const widths = row.map(col => {\n            if (col.width) {\n                unset--;\n                remainingWidth -= col.width;\n                return col.width;\n            }\n            return undefined;\n        });\n        // any unset widths should be calculated.\n        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n        return widths.map((w, i) => {\n            if (w === undefined) {\n                return Math.max(unsetWidth, _minWidth(row[i]));\n            }\n            return w;\n        });\n    }\n}\nfunction addBorder(col, ts, style) {\n    if (col.border) {\n        if (/[.']-+[.']/.test(ts)) {\n            return '';\n        }\n        if (ts.trim().length !== 0) {\n            return style;\n        }\n        return '  ';\n    }\n    return '';\n}\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth(col) {\n    const padding = col.padding || [];\n    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n    if (col.border) {\n        return minWidth + 4;\n    }\n    return minWidth;\n}\nfunction getWindowWidth() {\n    /* istanbul ignore next: depends on terminal */\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n        return process.stdout.columns;\n    }\n    return 80;\n}\nfunction alignRight(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    if (strWidth < width) {\n        return ' '.repeat(width - strWidth) + str;\n    }\n    return str;\n}\nfunction alignCenter(str, width) {\n    str = str.trim();\n    const strWidth = mixin.stringWidth(str);\n    /* istanbul ignore next */\n    if (strWidth >= width) {\n        return str;\n    }\n    return ' '.repeat((width - strWidth) >> 1) + str;\n}\nlet mixin;\nexport function cliui(opts, _mixin) {\n    mixin = _mixin;\n    return new UI({\n        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),\n        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}