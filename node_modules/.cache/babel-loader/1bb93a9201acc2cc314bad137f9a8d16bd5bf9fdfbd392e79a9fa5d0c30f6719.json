{"ast":null,"code":"import { command as Command } from './command.js';\nimport { assertNotStrictEqual, assertSingleKey, objectKeys } from './typings/common-types.js';\nimport { YError } from './yerror.js';\nimport { usage as Usage } from './usage.js';\nimport { argsert } from './argsert.js';\nimport { completion as Completion } from './completion.js';\nimport { validation as Validation } from './validation.js';\nimport { objFilter } from './utils/obj-filter.js';\nimport { applyExtends } from './utils/apply-extends.js';\nimport { globalMiddlewareFactory } from './middleware.js';\nimport { isPromise } from './utils/is-promise.js';\nimport setBlocking from './utils/set-blocking.js';\nlet shim;\nexport function YargsWithShim(_shim) {\n  shim = _shim;\n  return Yargs;\n}\nfunction Yargs() {\n  let processArgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let cwd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : shim.process.cwd();\n  let parentRequire = arguments.length > 2 ? arguments[2] : undefined;\n  const self = {};\n  let command;\n  let completion = null;\n  let groups = {};\n  const globalMiddleware = [];\n  let output = '';\n  const preservedGroups = {};\n  let usage;\n  let validation;\n  let handlerFinishCommand = null;\n  const y18n = shim.y18n;\n  self.middleware = globalMiddlewareFactory(globalMiddleware, self);\n  self.scriptName = function (scriptName) {\n    self.customScriptName = true;\n    self.$0 = scriptName;\n    return self;\n  };\n  let default$0;\n  if (/\\b(node|iojs|electron)(\\.exe)?$/.test(shim.process.argv()[0])) {\n    default$0 = shim.process.argv().slice(1, 2);\n  } else {\n    default$0 = shim.process.argv().slice(0, 1);\n  }\n  self.$0 = default$0.map(x => {\n    const b = rebase(cwd, x);\n    return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n  }).join(' ').trim();\n  if (shim.getEnv('_') && shim.getProcessArgvBin() === shim.getEnv('_')) {\n    self.$0 = shim.getEnv('_').replace(`${shim.path.dirname(shim.process.execPath())}/`, '');\n  }\n  const context = {\n    resets: -1,\n    commands: [],\n    fullCommands: [],\n    files: []\n  };\n  self.getContext = () => context;\n  let hasOutput = false;\n  let exitError = null;\n  self.exit = (code, err) => {\n    hasOutput = true;\n    exitError = err;\n    if (exitProcess) shim.process.exit(code);\n  };\n  let completionCommand = null;\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n    if (typeof desc === 'function') {\n      fn = desc;\n      desc = undefined;\n    }\n    completionCommand = cmd || completionCommand || 'completion';\n    if (!desc && desc !== false) {\n      desc = 'generate completion script';\n    }\n    self.command(completionCommand, desc);\n    if (fn) completion.registerFunction(fn);\n    return self;\n  };\n  let options;\n  self.resetOptions = self.reset = function resetOptions() {\n    let aliases = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    context.resets++;\n    options = options || {};\n    const tmpOptions = {};\n    tmpOptions.local = options.local ? options.local : [];\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : [];\n    const localLookup = {};\n    tmpOptions.local.forEach(l => {\n      localLookup[l] = true;\n      (aliases[l] || []).forEach(a => {\n        localLookup[a] = true;\n      });\n    });\n    Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n      const keys = groups[groupName].filter(key => !(key in localLookup));\n      if (keys.length > 0) {\n        acc[groupName] = keys;\n      }\n      return acc;\n    }, {}));\n    groups = {};\n    const arrayOptions = ['array', 'boolean', 'string', 'skipValidation', 'count', 'normalize', 'number', 'hiddenOptions'];\n    const objectOptions = ['narg', 'key', 'alias', 'default', 'defaultDescription', 'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce', 'deprecatedOptions'];\n    arrayOptions.forEach(k => {\n      tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\n    });\n    objectOptions.forEach(k => {\n      tmpOptions[k] = objFilter(options[k], k => !localLookup[k]);\n    });\n    tmpOptions.envPrefix = options.envPrefix;\n    options = tmpOptions;\n    usage = usage ? usage.reset(localLookup) : Usage(self, y18n, shim);\n    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n, shim);\n    command = command ? command.reset() : Command(self, usage, validation, globalMiddleware, shim);\n    if (!completion) completion = Completion(self, usage, command, shim);\n    completionCommand = null;\n    output = '';\n    exitError = null;\n    hasOutput = false;\n    self.parsed = false;\n    return self;\n  };\n  self.resetOptions();\n  const frozens = [];\n  function freeze() {\n    frozens.push({\n      options,\n      configObjects: options.configObjects.slice(0),\n      exitProcess,\n      groups,\n      strict,\n      strictCommands,\n      strictOptions,\n      completionCommand,\n      output,\n      exitError,\n      hasOutput,\n      parsed: self.parsed,\n      parseFn,\n      parseContext,\n      handlerFinishCommand\n    });\n    usage.freeze();\n    validation.freeze();\n    command.freeze();\n  }\n  function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    let configObjects;\n    ({\n      options,\n      configObjects,\n      exitProcess,\n      groups,\n      output,\n      exitError,\n      hasOutput,\n      parsed: self.parsed,\n      strict,\n      strictCommands,\n      strictOptions,\n      completionCommand,\n      parseFn,\n      parseContext,\n      handlerFinishCommand\n    } = frozen);\n    options.configObjects = configObjects;\n    usage.unfreeze();\n    validation.unfreeze();\n    command.unfreeze();\n  }\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('boolean', keys);\n    return self;\n  };\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('array', keys);\n    return self;\n  };\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('number', keys);\n    return self;\n  };\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('normalize', keys);\n    return self;\n  };\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('count', keys);\n    return self;\n  };\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('string', keys);\n    return self;\n  };\n  self.requiresArg = function (keys) {\n    argsert('<array|string|object> [number]', [keys], arguments.length);\n    if (typeof keys === 'string' && options.narg[keys]) {\n      return self;\n    } else {\n      populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n    }\n    return self;\n  };\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('skipValidation', keys);\n    return self;\n  };\n  function populateParserHintArray(type, keys) {\n    keys = [].concat(keys);\n    keys.forEach(key => {\n      key = sanitizeKey(key);\n      options[type].push(key);\n    });\n  }\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length);\n    populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n    return self;\n  };\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n    return self;\n  };\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n    return self;\n  };\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n    if (defaultDescription) {\n      assertSingleKey(key, shim);\n      options.defaultDescription[key] = defaultDescription;\n    }\n    if (typeof value === 'function') {\n      assertSingleKey(key, shim);\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value);\n      value = value.call();\n    }\n    populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n    return self;\n  };\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length);\n    setKey(key, true);\n    usage.describe(key, desc);\n    return self;\n  };\n  function setKey(key, set) {\n    populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n    return self;\n  }\n  function demandOption(keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n    populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n    return self;\n  }\n  self.demandOption = demandOption;\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length);\n    populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n    return self;\n  };\n  function populateParserHintSingleValueDictionary(builder, type, key, value) {\n    populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n      options[type][key] = value;\n    });\n  }\n  function populateParserHintArrayDictionary(builder, type, key, value) {\n    populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n      options[type][key] = (options[type][key] || []).concat(value);\n    });\n  }\n  function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n    if (Array.isArray(key)) {\n      key.forEach(k => {\n        builder(k, value);\n      });\n    } else if ((key => typeof key === 'object')(key)) {\n      for (const k of objectKeys(key)) {\n        builder(k, key[k]);\n      }\n    } else {\n      singleKeyHandler(type, sanitizeKey(key), value);\n    }\n  }\n  function sanitizeKey(key) {\n    if (key === '__proto__') return '___proto___';\n    return key;\n  }\n  function deleteFromParserHintObject(optionKey) {\n    objectKeys(options).forEach(hintKey => {\n      if ((key => key === 'configObjects')(hintKey)) return;\n      const hint = options[hintKey];\n      if (Array.isArray(hint)) {\n        if (~hint.indexOf(optionKey)) hint.splice(hint.indexOf(optionKey), 1);\n      } else if (typeof hint === 'object') {\n        delete hint[optionKey];\n      }\n    });\n    delete usage.getDescriptions()[optionKey];\n  }\n  self.config = function config() {\n    let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'config';\n    let msg = arguments.length > 1 ? arguments[1] : undefined;\n    let parseFn = arguments.length > 2 ? arguments[2] : undefined;\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n    if (typeof key === 'object' && !Array.isArray(key)) {\n      key = applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim);\n      options.configObjects = (options.configObjects || []).concat(key);\n      return self;\n    }\n    if (typeof msg === 'function') {\n      parseFn = msg;\n      msg = undefined;\n    }\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n    (Array.isArray(key) ? key : [key]).forEach(k => {\n      options.config[k] = parseFn || true;\n    });\n    return self;\n  };\n  self.example = function (cmd, description) {\n    argsert('<string|array> [string]', [cmd, description], arguments.length);\n    if (Array.isArray(cmd)) {\n      cmd.forEach(exampleParams => self.example(...exampleParams));\n    } else {\n      usage.example(cmd, description);\n    }\n    return self;\n  };\n  self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n    command.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n    return self;\n  };\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length);\n    const req = parentRequire || shim.require;\n    command.addDirectory(dir, self.getContext(), req, shim.getCallerFile(), opts);\n    return self;\n  };\n  self.demand = self.required = self.require = function demand(keys, max, msg) {\n    if (Array.isArray(max)) {\n      max.forEach(key => {\n        assertNotStrictEqual(msg, true, shim);\n        demandOption(key, msg);\n      });\n      max = Infinity;\n    } else if (typeof max !== 'number') {\n      msg = max;\n      max = Infinity;\n    }\n    if (typeof keys === 'number') {\n      assertNotStrictEqual(msg, true, shim);\n      self.demandCommand(keys, max, msg, msg);\n    } else if (Array.isArray(keys)) {\n      keys.forEach(key => {\n        assertNotStrictEqual(msg, true, shim);\n        demandOption(key, msg);\n      });\n    } else {\n      if (typeof msg === 'string') {\n        demandOption(keys, msg);\n      } else if (msg === true || typeof msg === 'undefined') {\n        demandOption(keys);\n      }\n    }\n    return self;\n  };\n  self.demandCommand = function demandCommand() {\n    let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let max = arguments.length > 1 ? arguments[1] : undefined;\n    let minMsg = arguments.length > 2 ? arguments[2] : undefined;\n    let maxMsg = arguments.length > 3 ? arguments[3] : undefined;\n    argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n    if (typeof max !== 'number') {\n      minMsg = max;\n      max = Infinity;\n    }\n    self.global('_', false);\n    options.demandedCommands._ = {\n      min,\n      max,\n      minMsg,\n      maxMsg\n    };\n    return self;\n  };\n  self.getDemandedOptions = () => {\n    argsert([], 0);\n    return options.demandedOptions;\n  };\n  self.getDemandedCommands = () => {\n    argsert([], 0);\n    return options.demandedCommands;\n  };\n  self.deprecateOption = function deprecateOption(option, message) {\n    argsert('<string> [string|boolean]', [option, message], arguments.length);\n    options.deprecatedOptions[option] = message;\n    return self;\n  };\n  self.getDeprecatedOptions = () => {\n    argsert([], 0);\n    return options.deprecatedOptions;\n  };\n  self.implies = function (key, value) {\n    argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n    validation.implies(key, value);\n    return self;\n  };\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n    validation.conflicts(key1, key2);\n    return self;\n  };\n  self.usage = function (msg, description, builder, handler) {\n    argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n    if (description !== undefined) {\n      assertNotStrictEqual(msg, null, shim);\n      if ((msg || '').match(/^\\$0( |$)/)) {\n        return self.command(msg, description, builder, handler);\n      } else {\n        throw new YError('.usage() description must start with $0 if being used as alias for .command()');\n      }\n    } else {\n      usage.usage(msg);\n      return self;\n    }\n  };\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length);\n    usage.epilog(msg);\n    return self;\n  };\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length);\n    usage.failFn(f);\n    return self;\n  };\n  self.onFinishCommand = function (f) {\n    argsert('<function>', [f], arguments.length);\n    handlerFinishCommand = f;\n    return self;\n  };\n  self.getHandlerFinishCommand = () => handlerFinishCommand;\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length);\n    validation.check(f, _global !== false);\n    return self;\n  };\n  self.global = function global(globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length);\n    globals = [].concat(globals);\n    if (global !== false) {\n      options.local = options.local.filter(l => globals.indexOf(l) === -1);\n    } else {\n      globals.forEach(g => {\n        if (options.local.indexOf(g) === -1) options.local.push(g);\n      });\n    }\n    return self;\n  };\n  self.pkgConf = function pkgConf(key, rootPath) {\n    argsert('<string> [string]', [key, rootPath], arguments.length);\n    let conf = null;\n    const obj = pkgUp(rootPath || cwd);\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim);\n      options.configObjects = (options.configObjects || []).concat(conf);\n    }\n    return self;\n  };\n  const pkgs = {};\n  function pkgUp(rootPath) {\n    const npath = rootPath || '*';\n    if (pkgs[npath]) return pkgs[npath];\n    let obj = {};\n    try {\n      let startDir = rootPath || shim.mainFilename;\n      if (!rootPath && shim.path.extname(startDir)) {\n        startDir = shim.path.dirname(startDir);\n      }\n      const pkgJsonPath = shim.findUp(startDir, (dir, names) => {\n        if (names.includes('package.json')) {\n          return 'package.json';\n        } else {\n          return undefined;\n        }\n      });\n      assertNotStrictEqual(pkgJsonPath, undefined, shim);\n      obj = JSON.parse(shim.readFileSync(pkgJsonPath, 'utf8'));\n    } catch (_noop) {}\n    pkgs[npath] = obj || {};\n    return pkgs[npath];\n  }\n  let parseFn = null;\n  let parseContext = null;\n  self.parse = function parse(args, shortCircuit, _parseFn) {\n    argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n    freeze();\n    if (typeof args === 'undefined') {\n      const argv = self._parseArgs(processArgs);\n      const tmpParsed = self.parsed;\n      unfreeze();\n      self.parsed = tmpParsed;\n      return argv;\n    }\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit;\n      shortCircuit = _parseFn;\n    }\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit;\n      shortCircuit = false;\n    }\n    if (!shortCircuit) processArgs = args;\n    if (parseFn) exitProcess = false;\n    const parsed = self._parseArgs(args, !!shortCircuit);\n    completion.setParsed(self.parsed);\n    if (parseFn) parseFn(exitError, parsed, output);\n    unfreeze();\n    return parsed;\n  };\n  self._getParseContext = () => parseContext || {};\n  self._hasParseCallback = () => !!parseFn;\n  self.option = self.options = function option(key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.options(k, key[k]);\n      });\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {};\n      }\n      options.key[key] = true;\n      if (opt.alias) self.alias(key, opt.alias);\n      const deprecate = opt.deprecate || opt.deprecated;\n      if (deprecate) {\n        self.deprecateOption(key, deprecate);\n      }\n      const demand = opt.demand || opt.required || opt.require;\n      if (demand) {\n        self.demand(key, demand);\n      }\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n      }\n      if (opt.conflicts) {\n        self.conflicts(key, opt.conflicts);\n      }\n      if ('default' in opt) {\n        self.default(key, opt.default);\n      }\n      if (opt.implies !== undefined) {\n        self.implies(key, opt.implies);\n      }\n      if (opt.nargs !== undefined) {\n        self.nargs(key, opt.nargs);\n      }\n      if (opt.config) {\n        self.config(key, opt.configParser);\n      }\n      if (opt.normalize) {\n        self.normalize(key);\n      }\n      if (opt.choices) {\n        self.choices(key, opt.choices);\n      }\n      if (opt.coerce) {\n        self.coerce(key, opt.coerce);\n      }\n      if (opt.group) {\n        self.group(key, opt.group);\n      }\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key);\n        if (opt.alias) self.boolean(opt.alias);\n      }\n      if (opt.array || opt.type === 'array') {\n        self.array(key);\n        if (opt.alias) self.array(opt.alias);\n      }\n      if (opt.number || opt.type === 'number') {\n        self.number(key);\n        if (opt.alias) self.number(opt.alias);\n      }\n      if (opt.string || opt.type === 'string') {\n        self.string(key);\n        if (opt.alias) self.string(opt.alias);\n      }\n      if (opt.count || opt.type === 'count') {\n        self.count(key);\n      }\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global);\n      }\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription;\n      }\n      if (opt.skipValidation) {\n        self.skipValidation(key);\n      }\n      const desc = opt.describe || opt.description || opt.desc;\n      self.describe(key, desc);\n      if (opt.hidden) {\n        self.hide(key);\n      }\n      if (opt.requiresArg) {\n        self.requiresArg(key);\n      }\n    }\n    return self;\n  };\n  self.getOptions = () => options;\n  self.positional = function (key, opts) {\n    argsert('<string> <object>', [key, opts], arguments.length);\n    if (context.resets === 0) {\n      throw new YError(\".positional() can only be called in a command's builder function\");\n    }\n    const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize', 'choices', 'conflicts', 'coerce', 'type', 'describe', 'desc', 'description', 'alias'];\n    opts = objFilter(opts, (k, v) => {\n      let accept = supportedOpts.indexOf(k) !== -1;\n      if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1) accept = false;\n      return accept;\n    });\n    const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n    const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n      array: [],\n      alias: {},\n      default: {},\n      demand: {}\n    };\n    objectKeys(parseOptions).forEach(pk => {\n      const parseOption = parseOptions[pk];\n      if (Array.isArray(parseOption)) {\n        if (parseOption.indexOf(key) !== -1) opts[pk] = true;\n      } else {\n        if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];\n      }\n    });\n    self.group(key, usage.getPositionalGroupName());\n    return self.option(key, opts);\n  };\n  self.group = function group(opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length);\n    const existing = preservedGroups[groupName] || groups[groupName];\n    if (preservedGroups[groupName]) {\n      delete preservedGroups[groupName];\n    }\n    const seen = {};\n    groups[groupName] = (existing || []).concat(opts).filter(key => {\n      if (seen[key]) return false;\n      return seen[key] = true;\n    });\n    return self;\n  };\n  self.getGroups = () => Object.assign({}, groups, preservedGroups);\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length);\n    if (prefix === false) delete options.envPrefix;else options.envPrefix = prefix || '';\n    return self;\n  };\n  self.wrap = function (cols) {\n    argsert('<number|null|undefined>', [cols], arguments.length);\n    usage.wrap(cols);\n    return self;\n  };\n  let strict = false;\n  self.strict = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strict = enabled !== false;\n    return self;\n  };\n  self.getStrict = () => strict;\n  let strictCommands = false;\n  self.strictCommands = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strictCommands = enabled !== false;\n    return self;\n  };\n  self.getStrictCommands = () => strictCommands;\n  let strictOptions = false;\n  self.strictOptions = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length);\n    strictOptions = enabled !== false;\n    return self;\n  };\n  self.getStrictOptions = () => strictOptions;\n  let parserConfig = {};\n  self.parserConfiguration = function parserConfiguration(config) {\n    argsert('<object>', [config], arguments.length);\n    parserConfig = config;\n    return self;\n  };\n  self.getParserConfiguration = () => parserConfig;\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length);\n    if (!self.parsed) self._parseArgs(processArgs);\n    if (command.hasDefaultCommand()) {\n      context.resets++;\n      command.runDefaultBuilderOn(self);\n    }\n    usage.showHelp(level);\n    return self;\n  };\n  let versionOpt = null;\n  self.version = function version(opt, msg, ver) {\n    const defaultVersionOpt = 'version';\n    argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n    if (versionOpt) {\n      deleteFromParserHintObject(versionOpt);\n      usage.version(undefined);\n      versionOpt = null;\n    }\n    if (arguments.length === 0) {\n      ver = guessVersion();\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 1) {\n      if (opt === false) {\n        return self;\n      }\n      ver = opt;\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 2) {\n      ver = msg;\n      msg = undefined;\n    }\n    versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n    msg = msg || usage.deferY18nLookup('Show version number');\n    usage.version(ver || undefined);\n    self.boolean(versionOpt);\n    self.describe(versionOpt, msg);\n    return self;\n  };\n  function guessVersion() {\n    const obj = pkgUp();\n    return obj.version || 'unknown';\n  }\n  let helpOpt = null;\n  self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n    const defaultHelpOpt = 'help';\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n    if (helpOpt) {\n      deleteFromParserHintObject(helpOpt);\n      helpOpt = null;\n    }\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    }\n    helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n    self.boolean(helpOpt);\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n    return self;\n  };\n  const defaultShowHiddenOpt = 'show-hidden';\n  options.showHiddenOpt = defaultShowHiddenOpt;\n  self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    }\n    const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n    self.boolean(showHiddenOpt);\n    self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\n    options.showHiddenOpt = showHiddenOpt;\n    return self;\n  };\n  self.hide = function hide(key) {\n    argsert('<string>', [key], arguments.length);\n    options.hiddenOptions.push(key);\n    return self;\n  };\n  self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n    usage.showHelpOnFail(enabled, message);\n    return self;\n  };\n  let exitProcess = true;\n  self.exitProcess = function () {\n    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    argsert('[boolean]', [enabled], arguments.length);\n    exitProcess = enabled;\n    return self;\n  };\n  self.getExitProcess = () => exitProcess;\n  self.showCompletionScript = function ($0, cmd) {\n    argsert('[string] [string]', [$0, cmd], arguments.length);\n    $0 = $0 || self.$0;\n    _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n    return self;\n  };\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length);\n    completion.getCompletion(args, done);\n  };\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length);\n    if (!locale) {\n      guessLocale();\n      return y18n.getLocale();\n    }\n    detectLocale = false;\n    y18n.setLocale(locale);\n    return self;\n  };\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length);\n    detectLocale = false;\n    y18n.updateLocale(obj);\n    return self;\n  };\n  let detectLocale = true;\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length);\n    detectLocale = detect;\n    return self;\n  };\n  self.getDetectLocale = () => detectLocale;\n  const _logger = {\n    log() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (!self._hasParseCallback()) console.log(...args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    },\n    error() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      if (!self._hasParseCallback()) console.error(...args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    }\n  };\n  self._getLoggerInstance = () => _logger;\n  self._hasOutput = () => hasOutput;\n  self._setHasOutput = () => {\n    hasOutput = true;\n  };\n  let recommendCommands;\n  self.recommendCommands = function () {\n    let recommend = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    argsert('[boolean]', [recommend], arguments.length);\n    recommendCommands = recommend;\n    return self;\n  };\n  self.getUsageInstance = () => usage;\n  self.getValidationInstance = () => validation;\n  self.getCommandInstance = () => command;\n  self.terminalWidth = () => {\n    argsert([], 0);\n    return shim.process.stdColumns;\n  };\n  Object.defineProperty(self, 'argv', {\n    get: () => self._parseArgs(processArgs),\n    enumerable: true\n  });\n  self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n    let skipValidation = !!_calledFromCommand;\n    args = args || processArgs;\n    options.__ = y18n.__;\n    options.configuration = self.getParserConfiguration();\n    const populateDoubleDash = !!options.configuration['populate--'];\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    });\n    const parsed = shim.Parser.detailed(args, Object.assign({}, options, {\n      configuration: Object.assign({\n        'parse-positional-numbers': false\n      }, config)\n    }));\n    let argv = parsed.argv;\n    if (parseContext) argv = Object.assign({}, argv, parseContext);\n    const aliases = parsed.aliases;\n    argv.$0 = self.$0;\n    self.parsed = parsed;\n    try {\n      guessLocale();\n      if (shortCircuit) {\n        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n      }\n      if (helpOpt) {\n        const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter(k => k.length > 1);\n        if (~helpCmds.indexOf('' + argv._[argv._.length - 1])) {\n          argv._.pop();\n          argv[helpOpt] = true;\n        }\n      }\n      const handlerKeys = command.getCommands();\n      const requestCompletions = (completion.completionKey in argv);\n      const skipRecommendation = argv[helpOpt] || requestCompletions;\n      const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n      if (argv._.length) {\n        if (handlerKeys.length) {\n          let firstUnknownCommand;\n          for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i]);\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              const innerArgv = command.runCommand(cmd, self, parsed, i + 1);\n              return self._postProcess(innerArgv, populateDoubleDash);\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd;\n              break;\n            }\n          }\n          if (command.hasDefaultCommand() && !skipDefaultCommand) {\n            const innerArgv = command.runCommand(null, self, parsed);\n            return self._postProcess(innerArgv, populateDoubleDash);\n          }\n          if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys);\n          }\n        }\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n          if (exitProcess) setBlocking(true);\n          self.showCompletionScript();\n          self.exit(0);\n        }\n      } else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n        const innerArgv = command.runCommand(null, self, parsed);\n        return self._postProcess(innerArgv, populateDoubleDash);\n      }\n      if (requestCompletions) {\n        if (exitProcess) setBlocking(true);\n        args = [].concat(args);\n        const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);\n        completion.getCompletion(completionArgs, completions => {\n          (completions || []).forEach(completion => {\n            _logger.log(completion);\n          });\n          self.exit(0);\n        });\n        return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);\n      }\n      if (!hasOutput) {\n        Object.keys(argv).forEach(key => {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            self.showHelp('log');\n            self.exit(0);\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            usage.showVersion();\n            self.exit(0);\n          }\n        });\n      }\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n      }\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message);\n        if (!requestCompletions) {\n          self._runValidation(argv, aliases, {}, parsed.error);\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage.fail(err.message, err);else throw err;\n    }\n    return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n  };\n  self._postProcess = function (argv, populateDoubleDash) {\n    let calledFromCommand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (isPromise(argv)) return argv;\n    if (calledFromCommand) return argv;\n    if (!populateDoubleDash) {\n      argv = self._copyDoubleDash(argv);\n    }\n    const parsePositionalNumbers = self.getParserConfiguration()['parse-positional-numbers'] || self.getParserConfiguration()['parse-positional-numbers'] === undefined;\n    if (parsePositionalNumbers) {\n      argv = self._parsePositionalNumbers(argv);\n    }\n    return argv;\n  };\n  self._copyDoubleDash = function (argv) {\n    if (!argv._ || !argv['--']) return argv;\n    argv._.push.apply(argv._, argv['--']);\n    try {\n      delete argv['--'];\n    } catch (_err) {}\n    return argv;\n  };\n  self._parsePositionalNumbers = function (argv) {\n    const args = argv['--'] ? argv['--'] : argv._;\n    for (let i = 0, arg; (arg = args[i]) !== undefined; i++) {\n      if (shim.Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {\n        args[i] = Number(arg);\n      }\n    }\n    return argv;\n  };\n  self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors) {\n    let isDefaultCommand = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (parseErrors) throw new YError(parseErrors.message);\n    validation.nonOptionCount(argv);\n    validation.requiredArguments(argv);\n    let failedStrictCommands = false;\n    if (strictCommands) {\n      failedStrictCommands = validation.unknownCommands(argv);\n    }\n    if (strict && !failedStrictCommands) {\n      validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n    } else if (strictOptions) {\n      validation.unknownArguments(argv, aliases, {}, false, false);\n    }\n    validation.customChecks(argv, aliases);\n    validation.limitedChoices(argv);\n    validation.implications(argv);\n    validation.conflicting(argv);\n  };\n  function guessLocale() {\n    if (!detectLocale) return;\n    const locale = shim.getEnv('LC_ALL') || shim.getEnv('LC_MESSAGES') || shim.getEnv('LANG') || shim.getEnv('LANGUAGE') || 'en_US';\n    self.locale(locale.replace(/[.:].*/, ''));\n  }\n  self.help();\n  self.version();\n  return self;\n}\nexport const rebase = (base, dir) => shim.path.relative(base, dir);\nexport function isYargsInstance(y) {\n  return !!y && typeof y._parseArgs === 'function';\n}","map":{"version":3,"names":["command","Command","assertNotStrictEqual","assertSingleKey","objectKeys","YError","usage","Usage","argsert","completion","Completion","validation","Validation","objFilter","applyExtends","globalMiddlewareFactory","isPromise","setBlocking","shim","YargsWithShim","_shim","Yargs","processArgs","arguments","length","undefined","cwd","process","parentRequire","self","groups","globalMiddleware","output","preservedGroups","handlerFinishCommand","y18n","middleware","scriptName","customScriptName","$0","default$0","test","argv","slice","map","x","b","rebase","match","join","trim","getEnv","getProcessArgvBin","replace","path","dirname","execPath","context","resets","commands","fullCommands","files","getContext","hasOutput","exitError","exit","code","err","exitProcess","completionCommand","cmd","desc","fn","registerFunction","options","resetOptions","reset","aliases","tmpOptions","local","configObjects","localLookup","forEach","l","a","Object","assign","keys","reduce","acc","groupName","filter","key","arrayOptions","objectOptions","k","envPrefix","parsed","frozens","freeze","push","strict","strictCommands","strictOptions","parseFn","parseContext","unfreeze","frozen","pop","boolean","populateParserHintArray","array","number","normalize","count","string","requiresArg","narg","populateParserHintSingleValueDictionary","NaN","skipValidation","type","concat","sanitizeKey","nargs","value","choices","populateParserHintArrayDictionary","alias","default","defaults","defaultDescription","functionDescription","call","describe","setKey","set","demandOption","msg","coerce","builder","populateParserHintDictionary","singleKeyHandler","Array","isArray","deleteFromParserHintObject","optionKey","hintKey","hint","indexOf","splice","getDescriptions","config","getParserConfiguration","deferY18nLookup","example","description","exampleParams","handler","middlewares","deprecated","addHandler","commandDir","dir","opts","req","require","addDirectory","getCallerFile","demand","required","max","Infinity","demandCommand","min","minMsg","maxMsg","global","demandedCommands","_","getDemandedOptions","demandedOptions","getDemandedCommands","deprecateOption","option","message","deprecatedOptions","getDeprecatedOptions","implies","conflicts","key1","key2","epilogue","epilog","fail","f","failFn","onFinishCommand","getHandlerFinishCommand","check","_global","globals","g","pkgConf","rootPath","conf","obj","pkgUp","pkgs","npath","startDir","mainFilename","extname","pkgJsonPath","findUp","names","includes","JSON","parse","readFileSync","_noop","args","shortCircuit","_parseFn","_parseArgs","tmpParsed","setParsed","_getParseContext","_hasParseCallback","opt","deprecate","configParser","group","hidden","hide","getOptions","positional","supportedOpts","v","accept","fullCommand","parseOptions","cmdToParseOptions","pk","parseOption","getPositionalGroupName","existing","seen","getGroups","env","prefix","wrap","cols","enabled","getStrict","getStrictCommands","getStrictOptions","parserConfig","parserConfiguration","showHelp","level","hasDefaultCommand","runDefaultBuilderOn","versionOpt","version","ver","defaultVersionOpt","guessVersion","helpOpt","addHelpOpt","help","defaultHelpOpt","defaultShowHiddenOpt","showHiddenOpt","addShowHiddenOpt","showHidden","hiddenOptions","showHelpOnFail","getExitProcess","showCompletionScript","_logger","log","generateCompletionScript","getCompletion","done","locale","guessLocale","getLocale","detectLocale","setLocale","updateStrings","updateLocale","detect","getDetectLocale","_len","_key","console","error","_len2","_key2","_getLoggerInstance","_hasOutput","_setHasOutput","recommendCommands","recommend","getUsageInstance","getValidationInstance","getCommandInstance","terminalWidth","stdColumns","defineProperty","get","enumerable","parseArgs","_calledFromCommand","commandIndex","__","configuration","populateDoubleDash","Parser","detailed","_postProcess","helpCmds","handlerKeys","getCommands","requestCompletions","completionKey","skipRecommendation","skipDefaultCommand","firstUnknownCommand","i","String","innerArgv","runCommand","completionArgs","completions","showVersion","some","_runValidation","calledFromCommand","_copyDoubleDash","parsePositionalNumbers","_parsePositionalNumbers","apply","_err","arg","looksLikeNumber","Number","isSafeInteger","Math","floor","parseFloat","runValidation","positionalMap","parseErrors","isDefaultCommand","nonOptionCount","requiredArguments","failedStrictCommands","unknownCommands","unknownArguments","customChecks","limitedChoices","implications","conflicting","base","relative","isYargsInstance","y"],"sources":["/Users/lucasfrotabarroso/Desktop/util/react-algoritmo/node_modules/yargs/build/lib/yargs-factory.js"],"sourcesContent":["import { command as Command, } from './command.js';\nimport { assertNotStrictEqual, assertSingleKey, objectKeys, } from './typings/common-types.js';\nimport { YError } from './yerror.js';\nimport { usage as Usage } from './usage.js';\nimport { argsert } from './argsert.js';\nimport { completion as Completion, } from './completion.js';\nimport { validation as Validation, } from './validation.js';\nimport { objFilter } from './utils/obj-filter.js';\nimport { applyExtends } from './utils/apply-extends.js';\nimport { globalMiddlewareFactory, } from './middleware.js';\nimport { isPromise } from './utils/is-promise.js';\nimport setBlocking from './utils/set-blocking.js';\nlet shim;\nexport function YargsWithShim(_shim) {\n    shim = _shim;\n    return Yargs;\n}\nfunction Yargs(processArgs = [], cwd = shim.process.cwd(), parentRequire) {\n    const self = {};\n    let command;\n    let completion = null;\n    let groups = {};\n    const globalMiddleware = [];\n    let output = '';\n    const preservedGroups = {};\n    let usage;\n    let validation;\n    let handlerFinishCommand = null;\n    const y18n = shim.y18n;\n    self.middleware = globalMiddlewareFactory(globalMiddleware, self);\n    self.scriptName = function (scriptName) {\n        self.customScriptName = true;\n        self.$0 = scriptName;\n        return self;\n    };\n    let default$0;\n    if (/\\b(node|iojs|electron)(\\.exe)?$/.test(shim.process.argv()[0])) {\n        default$0 = shim.process.argv().slice(1, 2);\n    }\n    else {\n        default$0 = shim.process.argv().slice(0, 1);\n    }\n    self.$0 = default$0\n        .map(x => {\n        const b = rebase(cwd, x);\n        return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n    })\n        .join(' ')\n        .trim();\n    if (shim.getEnv('_') && shim.getProcessArgvBin() === shim.getEnv('_')) {\n        self.$0 = shim\n            .getEnv('_')\n            .replace(`${shim.path.dirname(shim.process.execPath())}/`, '');\n    }\n    const context = { resets: -1, commands: [], fullCommands: [], files: [] };\n    self.getContext = () => context;\n    let hasOutput = false;\n    let exitError = null;\n    self.exit = (code, err) => {\n        hasOutput = true;\n        exitError = err;\n        if (exitProcess)\n            shim.process.exit(code);\n    };\n    let completionCommand = null;\n    self.completion = function (cmd, desc, fn) {\n        argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n        if (typeof desc === 'function') {\n            fn = desc;\n            desc = undefined;\n        }\n        completionCommand = cmd || completionCommand || 'completion';\n        if (!desc && desc !== false) {\n            desc = 'generate completion script';\n        }\n        self.command(completionCommand, desc);\n        if (fn)\n            completion.registerFunction(fn);\n        return self;\n    };\n    let options;\n    self.resetOptions = self.reset = function resetOptions(aliases = {}) {\n        context.resets++;\n        options = options || {};\n        const tmpOptions = {};\n        tmpOptions.local = options.local ? options.local : [];\n        tmpOptions.configObjects = options.configObjects\n            ? options.configObjects\n            : [];\n        const localLookup = {};\n        tmpOptions.local.forEach(l => {\n            localLookup[l] = true;\n            (aliases[l] || []).forEach(a => {\n                localLookup[a] = true;\n            });\n        });\n        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n            const keys = groups[groupName].filter(key => !(key in localLookup));\n            if (keys.length > 0) {\n                acc[groupName] = keys;\n            }\n            return acc;\n        }, {}));\n        groups = {};\n        const arrayOptions = [\n            'array',\n            'boolean',\n            'string',\n            'skipValidation',\n            'count',\n            'normalize',\n            'number',\n            'hiddenOptions',\n        ];\n        const objectOptions = [\n            'narg',\n            'key',\n            'alias',\n            'default',\n            'defaultDescription',\n            'config',\n            'choices',\n            'demandedOptions',\n            'demandedCommands',\n            'coerce',\n            'deprecatedOptions',\n        ];\n        arrayOptions.forEach(k => {\n            tmpOptions[k] = (options[k] || []).filter((k) => !localLookup[k]);\n        });\n        objectOptions.forEach((k) => {\n            tmpOptions[k] = objFilter(options[k], k => !localLookup[k]);\n        });\n        tmpOptions.envPrefix = options.envPrefix;\n        options = tmpOptions;\n        usage = usage ? usage.reset(localLookup) : Usage(self, y18n, shim);\n        validation = validation\n            ? validation.reset(localLookup)\n            : Validation(self, usage, y18n, shim);\n        command = command\n            ? command.reset()\n            : Command(self, usage, validation, globalMiddleware, shim);\n        if (!completion)\n            completion = Completion(self, usage, command, shim);\n        completionCommand = null;\n        output = '';\n        exitError = null;\n        hasOutput = false;\n        self.parsed = false;\n        return self;\n    };\n    self.resetOptions();\n    const frozens = [];\n    function freeze() {\n        frozens.push({\n            options,\n            configObjects: options.configObjects.slice(0),\n            exitProcess,\n            groups,\n            strict,\n            strictCommands,\n            strictOptions,\n            completionCommand,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            parseFn,\n            parseContext,\n            handlerFinishCommand,\n        });\n        usage.freeze();\n        validation.freeze();\n        command.freeze();\n    }\n    function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        let configObjects;\n        ({\n            options,\n            configObjects,\n            exitProcess,\n            groups,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            strict,\n            strictCommands,\n            strictOptions,\n            completionCommand,\n            parseFn,\n            parseContext,\n            handlerFinishCommand,\n        } = frozen);\n        options.configObjects = configObjects;\n        usage.unfreeze();\n        validation.unfreeze();\n        command.unfreeze();\n    }\n    self.boolean = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('boolean', keys);\n        return self;\n    };\n    self.array = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('array', keys);\n        return self;\n    };\n    self.number = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('number', keys);\n        return self;\n    };\n    self.normalize = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('normalize', keys);\n        return self;\n    };\n    self.count = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('count', keys);\n        return self;\n    };\n    self.string = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('string', keys);\n        return self;\n    };\n    self.requiresArg = function (keys) {\n        argsert('<array|string|object> [number]', [keys], arguments.length);\n        if (typeof keys === 'string' && options.narg[keys]) {\n            return self;\n        }\n        else {\n            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n        }\n        return self;\n    };\n    self.skipValidation = function (keys) {\n        argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('skipValidation', keys);\n        return self;\n    };\n    function populateParserHintArray(type, keys) {\n        keys = [].concat(keys);\n        keys.forEach(key => {\n            key = sanitizeKey(key);\n            options[type].push(key);\n        });\n    }\n    self.nargs = function (key, value) {\n        argsert('<string|object|array> [number]', [key, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n        return self;\n    };\n    self.choices = function (key, value) {\n        argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n        return self;\n    };\n    self.alias = function (key, value) {\n        argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n        return self;\n    };\n    self.default = self.defaults = function (key, value, defaultDescription) {\n        argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n        if (defaultDescription) {\n            assertSingleKey(key, shim);\n            options.defaultDescription[key] = defaultDescription;\n        }\n        if (typeof value === 'function') {\n            assertSingleKey(key, shim);\n            if (!options.defaultDescription[key])\n                options.defaultDescription[key] = usage.functionDescription(value);\n            value = value.call();\n        }\n        populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n        return self;\n    };\n    self.describe = function (key, desc) {\n        argsert('<object|string|array> [string]', [key, desc], arguments.length);\n        setKey(key, true);\n        usage.describe(key, desc);\n        return self;\n    };\n    function setKey(key, set) {\n        populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n        return self;\n    }\n    function demandOption(keys, msg) {\n        argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n        return self;\n    }\n    self.demandOption = demandOption;\n    self.coerce = function (keys, value) {\n        argsert('<object|string|array> [function]', [keys, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n        return self;\n    };\n    function populateParserHintSingleValueDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = value;\n        });\n    }\n    function populateParserHintArrayDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = (options[type][key] || []).concat(value);\n        });\n    }\n    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n        if (Array.isArray(key)) {\n            key.forEach(k => {\n                builder(k, value);\n            });\n        }\n        else if (((key) => typeof key === 'object')(key)) {\n            for (const k of objectKeys(key)) {\n                builder(k, key[k]);\n            }\n        }\n        else {\n            singleKeyHandler(type, sanitizeKey(key), value);\n        }\n    }\n    function sanitizeKey(key) {\n        if (key === '__proto__')\n            return '___proto___';\n        return key;\n    }\n    function deleteFromParserHintObject(optionKey) {\n        objectKeys(options).forEach((hintKey) => {\n            if (((key) => key === 'configObjects')(hintKey))\n                return;\n            const hint = options[hintKey];\n            if (Array.isArray(hint)) {\n                if (~hint.indexOf(optionKey))\n                    hint.splice(hint.indexOf(optionKey), 1);\n            }\n            else if (typeof hint === 'object') {\n                delete hint[optionKey];\n            }\n        });\n        delete usage.getDescriptions()[optionKey];\n    }\n    self.config = function config(key = 'config', msg, parseFn) {\n        argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n        if (typeof key === 'object' && !Array.isArray(key)) {\n            key = applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim);\n            options.configObjects = (options.configObjects || []).concat(key);\n            return self;\n        }\n        if (typeof msg === 'function') {\n            parseFn = msg;\n            msg = undefined;\n        }\n        self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n        (Array.isArray(key) ? key : [key]).forEach(k => {\n            options.config[k] = parseFn || true;\n        });\n        return self;\n    };\n    self.example = function (cmd, description) {\n        argsert('<string|array> [string]', [cmd, description], arguments.length);\n        if (Array.isArray(cmd)) {\n            cmd.forEach(exampleParams => self.example(...exampleParams));\n        }\n        else {\n            usage.example(cmd, description);\n        }\n        return self;\n    };\n    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n        argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n        return self;\n    };\n    self.commandDir = function (dir, opts) {\n        argsert('<string> [object]', [dir, opts], arguments.length);\n        const req = parentRequire || shim.require;\n        command.addDirectory(dir, self.getContext(), req, shim.getCallerFile(), opts);\n        return self;\n    };\n    self.demand = self.required = self.require = function demand(keys, max, msg) {\n        if (Array.isArray(max)) {\n            max.forEach(key => {\n                assertNotStrictEqual(msg, true, shim);\n                demandOption(key, msg);\n            });\n            max = Infinity;\n        }\n        else if (typeof max !== 'number') {\n            msg = max;\n            max = Infinity;\n        }\n        if (typeof keys === 'number') {\n            assertNotStrictEqual(msg, true, shim);\n            self.demandCommand(keys, max, msg, msg);\n        }\n        else if (Array.isArray(keys)) {\n            keys.forEach(key => {\n                assertNotStrictEqual(msg, true, shim);\n                demandOption(key, msg);\n            });\n        }\n        else {\n            if (typeof msg === 'string') {\n                demandOption(keys, msg);\n            }\n            else if (msg === true || typeof msg === 'undefined') {\n                demandOption(keys);\n            }\n        }\n        return self;\n    };\n    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\n        argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n        if (typeof max !== 'number') {\n            minMsg = max;\n            max = Infinity;\n        }\n        self.global('_', false);\n        options.demandedCommands._ = {\n            min,\n            max,\n            minMsg,\n            maxMsg,\n        };\n        return self;\n    };\n    self.getDemandedOptions = () => {\n        argsert([], 0);\n        return options.demandedOptions;\n    };\n    self.getDemandedCommands = () => {\n        argsert([], 0);\n        return options.demandedCommands;\n    };\n    self.deprecateOption = function deprecateOption(option, message) {\n        argsert('<string> [string|boolean]', [option, message], arguments.length);\n        options.deprecatedOptions[option] = message;\n        return self;\n    };\n    self.getDeprecatedOptions = () => {\n        argsert([], 0);\n        return options.deprecatedOptions;\n    };\n    self.implies = function (key, value) {\n        argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n        validation.implies(key, value);\n        return self;\n    };\n    self.conflicts = function (key1, key2) {\n        argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n        validation.conflicts(key1, key2);\n        return self;\n    };\n    self.usage = function (msg, description, builder, handler) {\n        argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n        if (description !== undefined) {\n            assertNotStrictEqual(msg, null, shim);\n            if ((msg || '').match(/^\\$0( |$)/)) {\n                return self.command(msg, description, builder, handler);\n            }\n            else {\n                throw new YError('.usage() description must start with $0 if being used as alias for .command()');\n            }\n        }\n        else {\n            usage.usage(msg);\n            return self;\n        }\n    };\n    self.epilogue = self.epilog = function (msg) {\n        argsert('<string>', [msg], arguments.length);\n        usage.epilog(msg);\n        return self;\n    };\n    self.fail = function (f) {\n        argsert('<function>', [f], arguments.length);\n        usage.failFn(f);\n        return self;\n    };\n    self.onFinishCommand = function (f) {\n        argsert('<function>', [f], arguments.length);\n        handlerFinishCommand = f;\n        return self;\n    };\n    self.getHandlerFinishCommand = () => handlerFinishCommand;\n    self.check = function (f, _global) {\n        argsert('<function> [boolean]', [f, _global], arguments.length);\n        validation.check(f, _global !== false);\n        return self;\n    };\n    self.global = function global(globals, global) {\n        argsert('<string|array> [boolean]', [globals, global], arguments.length);\n        globals = [].concat(globals);\n        if (global !== false) {\n            options.local = options.local.filter(l => globals.indexOf(l) === -1);\n        }\n        else {\n            globals.forEach(g => {\n                if (options.local.indexOf(g) === -1)\n                    options.local.push(g);\n            });\n        }\n        return self;\n    };\n    self.pkgConf = function pkgConf(key, rootPath) {\n        argsert('<string> [string]', [key, rootPath], arguments.length);\n        let conf = null;\n        const obj = pkgUp(rootPath || cwd);\n        if (obj[key] && typeof obj[key] === 'object') {\n            conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim);\n            options.configObjects = (options.configObjects || []).concat(conf);\n        }\n        return self;\n    };\n    const pkgs = {};\n    function pkgUp(rootPath) {\n        const npath = rootPath || '*';\n        if (pkgs[npath])\n            return pkgs[npath];\n        let obj = {};\n        try {\n            let startDir = rootPath || shim.mainFilename;\n            if (!rootPath && shim.path.extname(startDir)) {\n                startDir = shim.path.dirname(startDir);\n            }\n            const pkgJsonPath = shim.findUp(startDir, (dir, names) => {\n                if (names.includes('package.json')) {\n                    return 'package.json';\n                }\n                else {\n                    return undefined;\n                }\n            });\n            assertNotStrictEqual(pkgJsonPath, undefined, shim);\n            obj = JSON.parse(shim.readFileSync(pkgJsonPath, 'utf8'));\n        }\n        catch (_noop) { }\n        pkgs[npath] = obj || {};\n        return pkgs[npath];\n    }\n    let parseFn = null;\n    let parseContext = null;\n    self.parse = function parse(args, shortCircuit, _parseFn) {\n        argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n        freeze();\n        if (typeof args === 'undefined') {\n            const argv = self._parseArgs(processArgs);\n            const tmpParsed = self.parsed;\n            unfreeze();\n            self.parsed = tmpParsed;\n            return argv;\n        }\n        if (typeof shortCircuit === 'object') {\n            parseContext = shortCircuit;\n            shortCircuit = _parseFn;\n        }\n        if (typeof shortCircuit === 'function') {\n            parseFn = shortCircuit;\n            shortCircuit = false;\n        }\n        if (!shortCircuit)\n            processArgs = args;\n        if (parseFn)\n            exitProcess = false;\n        const parsed = self._parseArgs(args, !!shortCircuit);\n        completion.setParsed(self.parsed);\n        if (parseFn)\n            parseFn(exitError, parsed, output);\n        unfreeze();\n        return parsed;\n    };\n    self._getParseContext = () => parseContext || {};\n    self._hasParseCallback = () => !!parseFn;\n    self.option = self.options = function option(key, opt) {\n        argsert('<string|object> [object]', [key, opt], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.options(k, key[k]);\n            });\n        }\n        else {\n            if (typeof opt !== 'object') {\n                opt = {};\n            }\n            options.key[key] = true;\n            if (opt.alias)\n                self.alias(key, opt.alias);\n            const deprecate = opt.deprecate || opt.deprecated;\n            if (deprecate) {\n                self.deprecateOption(key, deprecate);\n            }\n            const demand = opt.demand || opt.required || opt.require;\n            if (demand) {\n                self.demand(key, demand);\n            }\n            if (opt.demandOption) {\n                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n            }\n            if (opt.conflicts) {\n                self.conflicts(key, opt.conflicts);\n            }\n            if ('default' in opt) {\n                self.default(key, opt.default);\n            }\n            if (opt.implies !== undefined) {\n                self.implies(key, opt.implies);\n            }\n            if (opt.nargs !== undefined) {\n                self.nargs(key, opt.nargs);\n            }\n            if (opt.config) {\n                self.config(key, opt.configParser);\n            }\n            if (opt.normalize) {\n                self.normalize(key);\n            }\n            if (opt.choices) {\n                self.choices(key, opt.choices);\n            }\n            if (opt.coerce) {\n                self.coerce(key, opt.coerce);\n            }\n            if (opt.group) {\n                self.group(key, opt.group);\n            }\n            if (opt.boolean || opt.type === 'boolean') {\n                self.boolean(key);\n                if (opt.alias)\n                    self.boolean(opt.alias);\n            }\n            if (opt.array || opt.type === 'array') {\n                self.array(key);\n                if (opt.alias)\n                    self.array(opt.alias);\n            }\n            if (opt.number || opt.type === 'number') {\n                self.number(key);\n                if (opt.alias)\n                    self.number(opt.alias);\n            }\n            if (opt.string || opt.type === 'string') {\n                self.string(key);\n                if (opt.alias)\n                    self.string(opt.alias);\n            }\n            if (opt.count || opt.type === 'count') {\n                self.count(key);\n            }\n            if (typeof opt.global === 'boolean') {\n                self.global(key, opt.global);\n            }\n            if (opt.defaultDescription) {\n                options.defaultDescription[key] = opt.defaultDescription;\n            }\n            if (opt.skipValidation) {\n                self.skipValidation(key);\n            }\n            const desc = opt.describe || opt.description || opt.desc;\n            self.describe(key, desc);\n            if (opt.hidden) {\n                self.hide(key);\n            }\n            if (opt.requiresArg) {\n                self.requiresArg(key);\n            }\n        }\n        return self;\n    };\n    self.getOptions = () => options;\n    self.positional = function (key, opts) {\n        argsert('<string> <object>', [key, opts], arguments.length);\n        if (context.resets === 0) {\n            throw new YError(\".positional() can only be called in a command's builder function\");\n        }\n        const supportedOpts = [\n            'default',\n            'defaultDescription',\n            'implies',\n            'normalize',\n            'choices',\n            'conflicts',\n            'coerce',\n            'type',\n            'describe',\n            'desc',\n            'description',\n            'alias',\n        ];\n        opts = objFilter(opts, (k, v) => {\n            let accept = supportedOpts.indexOf(k) !== -1;\n            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)\n                accept = false;\n            return accept;\n        });\n        const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n        const parseOptions = fullCommand\n            ? command.cmdToParseOptions(fullCommand)\n            : {\n                array: [],\n                alias: {},\n                default: {},\n                demand: {},\n            };\n        objectKeys(parseOptions).forEach(pk => {\n            const parseOption = parseOptions[pk];\n            if (Array.isArray(parseOption)) {\n                if (parseOption.indexOf(key) !== -1)\n                    opts[pk] = true;\n            }\n            else {\n                if (parseOption[key] && !(pk in opts))\n                    opts[pk] = parseOption[key];\n            }\n        });\n        self.group(key, usage.getPositionalGroupName());\n        return self.option(key, opts);\n    };\n    self.group = function group(opts, groupName) {\n        argsert('<string|array> <string>', [opts, groupName], arguments.length);\n        const existing = preservedGroups[groupName] || groups[groupName];\n        if (preservedGroups[groupName]) {\n            delete preservedGroups[groupName];\n        }\n        const seen = {};\n        groups[groupName] = (existing || []).concat(opts).filter(key => {\n            if (seen[key])\n                return false;\n            return (seen[key] = true);\n        });\n        return self;\n    };\n    self.getGroups = () => Object.assign({}, groups, preservedGroups);\n    self.env = function (prefix) {\n        argsert('[string|boolean]', [prefix], arguments.length);\n        if (prefix === false)\n            delete options.envPrefix;\n        else\n            options.envPrefix = prefix || '';\n        return self;\n    };\n    self.wrap = function (cols) {\n        argsert('<number|null|undefined>', [cols], arguments.length);\n        usage.wrap(cols);\n        return self;\n    };\n    let strict = false;\n    self.strict = function (enabled) {\n        argsert('[boolean]', [enabled], arguments.length);\n        strict = enabled !== false;\n        return self;\n    };\n    self.getStrict = () => strict;\n    let strictCommands = false;\n    self.strictCommands = function (enabled) {\n        argsert('[boolean]', [enabled], arguments.length);\n        strictCommands = enabled !== false;\n        return self;\n    };\n    self.getStrictCommands = () => strictCommands;\n    let strictOptions = false;\n    self.strictOptions = function (enabled) {\n        argsert('[boolean]', [enabled], arguments.length);\n        strictOptions = enabled !== false;\n        return self;\n    };\n    self.getStrictOptions = () => strictOptions;\n    let parserConfig = {};\n    self.parserConfiguration = function parserConfiguration(config) {\n        argsert('<object>', [config], arguments.length);\n        parserConfig = config;\n        return self;\n    };\n    self.getParserConfiguration = () => parserConfig;\n    self.showHelp = function (level) {\n        argsert('[string|function]', [level], arguments.length);\n        if (!self.parsed)\n            self._parseArgs(processArgs);\n        if (command.hasDefaultCommand()) {\n            context.resets++;\n            command.runDefaultBuilderOn(self);\n        }\n        usage.showHelp(level);\n        return self;\n    };\n    let versionOpt = null;\n    self.version = function version(opt, msg, ver) {\n        const defaultVersionOpt = 'version';\n        argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n        if (versionOpt) {\n            deleteFromParserHintObject(versionOpt);\n            usage.version(undefined);\n            versionOpt = null;\n        }\n        if (arguments.length === 0) {\n            ver = guessVersion();\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 1) {\n            if (opt === false) {\n                return self;\n            }\n            ver = opt;\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 2) {\n            ver = msg;\n            msg = undefined;\n        }\n        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n        msg = msg || usage.deferY18nLookup('Show version number');\n        usage.version(ver || undefined);\n        self.boolean(versionOpt);\n        self.describe(versionOpt, msg);\n        return self;\n    };\n    function guessVersion() {\n        const obj = pkgUp();\n        return obj.version || 'unknown';\n    }\n    let helpOpt = null;\n    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n        const defaultHelpOpt = 'help';\n        argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        if (helpOpt) {\n            deleteFromParserHintObject(helpOpt);\n            helpOpt = null;\n        }\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n        self.boolean(helpOpt);\n        self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n        return self;\n    };\n    const defaultShowHiddenOpt = 'show-hidden';\n    options.showHiddenOpt = defaultShowHiddenOpt;\n    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n        argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n        self.boolean(showHiddenOpt);\n        self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\n        options.showHiddenOpt = showHiddenOpt;\n        return self;\n    };\n    self.hide = function hide(key) {\n        argsert('<string>', [key], arguments.length);\n        options.hiddenOptions.push(key);\n        return self;\n    };\n    self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n        argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n        usage.showHelpOnFail(enabled, message);\n        return self;\n    };\n    let exitProcess = true;\n    self.exitProcess = function (enabled = true) {\n        argsert('[boolean]', [enabled], arguments.length);\n        exitProcess = enabled;\n        return self;\n    };\n    self.getExitProcess = () => exitProcess;\n    self.showCompletionScript = function ($0, cmd) {\n        argsert('[string] [string]', [$0, cmd], arguments.length);\n        $0 = $0 || self.$0;\n        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n        return self;\n    };\n    self.getCompletion = function (args, done) {\n        argsert('<array> <function>', [args, done], arguments.length);\n        completion.getCompletion(args, done);\n    };\n    self.locale = function (locale) {\n        argsert('[string]', [locale], arguments.length);\n        if (!locale) {\n            guessLocale();\n            return y18n.getLocale();\n        }\n        detectLocale = false;\n        y18n.setLocale(locale);\n        return self;\n    };\n    self.updateStrings = self.updateLocale = function (obj) {\n        argsert('<object>', [obj], arguments.length);\n        detectLocale = false;\n        y18n.updateLocale(obj);\n        return self;\n    };\n    let detectLocale = true;\n    self.detectLocale = function (detect) {\n        argsert('<boolean>', [detect], arguments.length);\n        detectLocale = detect;\n        return self;\n    };\n    self.getDetectLocale = () => detectLocale;\n    const _logger = {\n        log(...args) {\n            if (!self._hasParseCallback())\n                console.log(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        },\n        error(...args) {\n            if (!self._hasParseCallback())\n                console.error(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        },\n    };\n    self._getLoggerInstance = () => _logger;\n    self._hasOutput = () => hasOutput;\n    self._setHasOutput = () => {\n        hasOutput = true;\n    };\n    let recommendCommands;\n    self.recommendCommands = function (recommend = true) {\n        argsert('[boolean]', [recommend], arguments.length);\n        recommendCommands = recommend;\n        return self;\n    };\n    self.getUsageInstance = () => usage;\n    self.getValidationInstance = () => validation;\n    self.getCommandInstance = () => command;\n    self.terminalWidth = () => {\n        argsert([], 0);\n        return shim.process.stdColumns;\n    };\n    Object.defineProperty(self, 'argv', {\n        get: () => self._parseArgs(processArgs),\n        enumerable: true,\n    });\n    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n        let skipValidation = !!_calledFromCommand;\n        args = args || processArgs;\n        options.__ = y18n.__;\n        options.configuration = self.getParserConfiguration();\n        const populateDoubleDash = !!options.configuration['populate--'];\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true,\n        });\n        const parsed = shim.Parser.detailed(args, Object.assign({}, options, {\n            configuration: Object.assign({ 'parse-positional-numbers': false }, config),\n        }));\n        let argv = parsed.argv;\n        if (parseContext)\n            argv = Object.assign({}, argv, parseContext);\n        const aliases = parsed.aliases;\n        argv.$0 = self.$0;\n        self.parsed = parsed;\n        try {\n            guessLocale();\n            if (shortCircuit) {\n                return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n            }\n            if (helpOpt) {\n                const helpCmds = [helpOpt]\n                    .concat(aliases[helpOpt] || [])\n                    .filter(k => k.length > 1);\n                if (~helpCmds.indexOf('' + argv._[argv._.length - 1])) {\n                    argv._.pop();\n                    argv[helpOpt] = true;\n                }\n            }\n            const handlerKeys = command.getCommands();\n            const requestCompletions = completion.completionKey in argv;\n            const skipRecommendation = argv[helpOpt] || requestCompletions;\n            const skipDefaultCommand = skipRecommendation &&\n                (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n            if (argv._.length) {\n                if (handlerKeys.length) {\n                    let firstUnknownCommand;\n                    for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n                        cmd = String(argv._[i]);\n                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);\n                            return self._postProcess(innerArgv, populateDoubleDash);\n                        }\n                        else if (!firstUnknownCommand && cmd !== completionCommand) {\n                            firstUnknownCommand = cmd;\n                            break;\n                        }\n                    }\n                    if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                        const innerArgv = command.runCommand(null, self, parsed);\n                        return self._postProcess(innerArgv, populateDoubleDash);\n                    }\n                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n                        validation.recommendCommands(firstUnknownCommand, handlerKeys);\n                    }\n                }\n                if (completionCommand &&\n                    ~argv._.indexOf(completionCommand) &&\n                    !requestCompletions) {\n                    if (exitProcess)\n                        setBlocking(true);\n                    self.showCompletionScript();\n                    self.exit(0);\n                }\n            }\n            else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                const innerArgv = command.runCommand(null, self, parsed);\n                return self._postProcess(innerArgv, populateDoubleDash);\n            }\n            if (requestCompletions) {\n                if (exitProcess)\n                    setBlocking(true);\n                args = [].concat(args);\n                const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);\n                completion.getCompletion(completionArgs, completions => {\n                    (completions || []).forEach(completion => {\n                        _logger.log(completion);\n                    });\n                    self.exit(0);\n                });\n                return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);\n            }\n            if (!hasOutput) {\n                Object.keys(argv).forEach(key => {\n                    if (key === helpOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        self.showHelp('log');\n                        self.exit(0);\n                    }\n                    else if (key === versionOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        usage.showVersion();\n                        self.exit(0);\n                    }\n                });\n            }\n            if (!skipValidation && options.skipValidation.length > 0) {\n                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n            }\n            if (!skipValidation) {\n                if (parsed.error)\n                    throw new YError(parsed.error.message);\n                if (!requestCompletions) {\n                    self._runValidation(argv, aliases, {}, parsed.error);\n                }\n            }\n        }\n        catch (err) {\n            if (err instanceof YError)\n                usage.fail(err.message, err);\n            else\n                throw err;\n        }\n        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);\n    };\n    self._postProcess = function (argv, populateDoubleDash, calledFromCommand = false) {\n        if (isPromise(argv))\n            return argv;\n        if (calledFromCommand)\n            return argv;\n        if (!populateDoubleDash) {\n            argv = self._copyDoubleDash(argv);\n        }\n        const parsePositionalNumbers = self.getParserConfiguration()['parse-positional-numbers'] ||\n            self.getParserConfiguration()['parse-positional-numbers'] === undefined;\n        if (parsePositionalNumbers) {\n            argv = self._parsePositionalNumbers(argv);\n        }\n        return argv;\n    };\n    self._copyDoubleDash = function (argv) {\n        if (!argv._ || !argv['--'])\n            return argv;\n        argv._.push.apply(argv._, argv['--']);\n        try {\n            delete argv['--'];\n        }\n        catch (_err) { }\n        return argv;\n    };\n    self._parsePositionalNumbers = function (argv) {\n        const args = argv['--'] ? argv['--'] : argv._;\n        for (let i = 0, arg; (arg = args[i]) !== undefined; i++) {\n            if (shim.Parser.looksLikeNumber(arg) &&\n                Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {\n                args[i] = Number(arg);\n            }\n        }\n        return argv;\n    };\n    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\n        if (parseErrors)\n            throw new YError(parseErrors.message);\n        validation.nonOptionCount(argv);\n        validation.requiredArguments(argv);\n        let failedStrictCommands = false;\n        if (strictCommands) {\n            failedStrictCommands = validation.unknownCommands(argv);\n        }\n        if (strict && !failedStrictCommands) {\n            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n        }\n        else if (strictOptions) {\n            validation.unknownArguments(argv, aliases, {}, false, false);\n        }\n        validation.customChecks(argv, aliases);\n        validation.limitedChoices(argv);\n        validation.implications(argv);\n        validation.conflicting(argv);\n    };\n    function guessLocale() {\n        if (!detectLocale)\n            return;\n        const locale = shim.getEnv('LC_ALL') ||\n            shim.getEnv('LC_MESSAGES') ||\n            shim.getEnv('LANG') ||\n            shim.getEnv('LANGUAGE') ||\n            'en_US';\n        self.locale(locale.replace(/[.:].*/, ''));\n    }\n    self.help();\n    self.version();\n    return self;\n}\nexport const rebase = (base, dir) => shim.path.relative(base, dir);\nexport function isYargsInstance(y) {\n    return !!y && typeof y._parseArgs === 'function';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}