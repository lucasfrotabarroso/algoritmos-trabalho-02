{"ast":null,"code":"import { argsert } from './argsert.js';\nimport { assertNotStrictEqual } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, y18n, shim) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {};\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands();\n    const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n    const _s = positionalCount - yargs.getContext().commands.length;\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString()) : null);\n        } else {\n          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString()) : null);\n        } else {\n          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n        }\n      }\n    }\n  };\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n    }\n  };\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n    for (const key of Object.keys(demandedOptions)) {\n      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    }\n    if (missing) {\n      const customMsgs = [];\n      for (const key of Object.keys(missing)) {\n        const msg = missing[key];\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      }\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  };\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n    let checkPositionals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  };\n  self.unknownCommands = function unknownCommands(argv) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf('' + key) === -1) {\n          unknown.push('' + key);\n        }\n      });\n    }\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n      return true;\n    } else {\n      return false;\n    }\n  };\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n      return false;\n    }\n    const newAliases = yargs.parsed.newAliases;\n    for (const a of [key, ...aliases[key]]) {\n      if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n        return true;\n      }\n    }\n    return false;\n  };\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {\n        [].concat(argv[key]).forEach(value => {\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n    let msg = __('Invalid values:');\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  };\n  let checks = [];\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  };\n  let implied = {};\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        assertNotStrictEqual(value, undefined, shim);\n        implied[key].push(value);\n      }\n    }\n  };\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n  function keyExists(argv, val) {\n    const num = Number(val);\n    val = isNaN(num) ? val : num;\n    if (typeof val === 'number') {\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      val = val.match(/^--no-(.+)/)[1];\n      val = !argv[val];\n    } else {\n      val = argv[val];\n    }\n    return val;\n  }\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n  let conflicting = {};\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n  self.getConflicting = () => conflicting;\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const threshold = 3;\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, k => !localLookup[k]);\n    conflicting = objFilter(conflicting, k => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n  const frozens = [];\n  self.freeze = function freeze() {\n    frozens.push({\n      implied,\n      checks,\n      conflicting\n    });\n  };\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      implied,\n      checks,\n      conflicting\n    } = frozen);\n  };\n  return self;\n}","map":{"version":3,"names":["argsert","assertNotStrictEqual","levenshtein","distance","objFilter","specialKeys","validation","yargs","usage","y18n","shim","__","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","positionalCount","_","length","_s","getContext","commands","min","max","minMsg","undefined","fail","replace","toString","maxMsg","required","observed","requiredArguments","demandedOptions","getDemandedOptions","missing","key","Object","keys","prototype","hasOwnProperty","call","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","isDefaultCommand","checkPositionals","arguments","commandKeys","getCommandInstance","getCommands","unknown","currentContext","forEach","_getParseContext","isValidAndSomeAliasIsNotNew","slice","unknownCommands","newAliases","parsed","a","limitedChoices","options","getOptions","invalid","choices","concat","value","invalidKeys","stringifiedValues","checks","check","f","global","func","customChecks","i","result","err","message","Error","implied","implies","k","Array","isArray","getImplied","keyExists","val","num","Number","isNaN","match","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","recommendCommands","cmd","potentialCommands","threshold","sort","b","recommended","bestDistance","Infinity","candidate","d","reset","localLookup","filter","c","frozens","freeze","unfreeze","frozen","pop"],"sources":["/Users/lucasfrotabarroso/Desktop/util/react-algoritmo/node_modules/yargs/build/lib/validation.js"],"sourcesContent":["import { argsert } from './argsert.js';\nimport { assertNotStrictEqual, } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, y18n, shim) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n        const _s = positionalCount - yargs.getContext().commands.length;\n        if (demandedCommands._ &&\n            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n                }\n            }\n        }\n    };\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n        }\n    };\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) ||\n                typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if (checkPositionals &&\n            (currentContext.commands.length > 0 ||\n                commandKeys.length > 0 ||\n                isDefaultCommand)) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (commandKeys.indexOf('' + key) === -1) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) ||\n                !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach(value => {\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach(key => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global,\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.implies(key, i));\n            }\n            else {\n                assertNotStrictEqual(value, undefined, shim);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach(key => {\n            const origKey = key;\n            (implied[key] || []).forEach(value => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach(value => {\n                msg += value;\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach(key => {\n            if (conflicting[key]) {\n                conflicting[key].forEach(value => {\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3;\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = distance(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = objFilter(implied, k => !localLookup[k]);\n        conflicting = objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting,\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ implied, checks, conflicting } = frozen);\n    };\n    return self;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}