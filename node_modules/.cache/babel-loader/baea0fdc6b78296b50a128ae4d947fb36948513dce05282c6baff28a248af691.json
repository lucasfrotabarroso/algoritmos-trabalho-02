{"ast":null,"code":"import { YError } from './yerror.js';\nimport { parseCommand } from './parse-command.js';\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nexport function argsert(arg1, arg2, arg3) {\n  function parseArgs() {\n    return typeof arg1 === 'object' ? [{\n      demanded: [],\n      optional: []\n    }, arg1, arg2] : [parseCommand(`cmd ${arg1}`), arg2, arg3];\n  }\n  try {\n    let position = 0;\n    const [parsed, callerArguments, _length] = parseArgs();\n    const args = [].slice.call(callerArguments);\n    while (args.length && args[args.length - 1] === undefined) args.pop();\n    const length = _length || args.length;\n    if (length < parsed.demanded.length) {\n      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n    }\n    const totalCommands = parsed.demanded.length + parsed.optional.length;\n    if (length > totalCommands) {\n      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n    }\n    parsed.demanded.forEach(demanded => {\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);\n      position += 1;\n    });\n    parsed.optional.forEach(optional => {\n      if (args.length === 0) return;\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);\n      position += 1;\n    });\n  } catch (err) {\n    console.warn(err.stack);\n  }\n}\nfunction guessType(arg) {\n  if (Array.isArray(arg)) {\n    return 'array';\n  } else if (arg === null) {\n    return 'null';\n  }\n  return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n  throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}","map":{"version":3,"names":["YError","parseCommand","positionName","argsert","arg1","arg2","arg3","parseArgs","demanded","optional","position","parsed","callerArguments","_length","args","slice","call","length","undefined","pop","totalCommands","forEach","arg","shift","observedType","guessType","matchingTypes","cmd","filter","type","argumentTypeError","err","console","warn","stack","Array","isArray","allowedTypes","join"],"sources":["/Users/lucasfrotabarroso/Desktop/util/react-algoritmo/node_modules/yargs/build/lib/argsert.js"],"sourcesContent":["import { YError } from './yerror.js';\nimport { parseCommand } from './parse-command.js';\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nexport function argsert(arg1, arg2, arg3) {\n    function parseArgs() {\n        return typeof arg1 === 'object'\n            ? [{ demanded: [], optional: [] }, arg1, arg2]\n            : [\n                parseCommand(`cmd ${arg1}`),\n                arg2,\n                arg3,\n            ];\n    }\n    try {\n        let position = 0;\n        const [parsed, callerArguments, _length] = parseArgs();\n        const args = [].slice.call(callerArguments);\n        while (args.length && args[args.length - 1] === undefined)\n            args.pop();\n        const length = _length || args.length;\n        if (length < parsed.demanded.length) {\n            throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n        }\n        const totalCommands = parsed.demanded.length + parsed.optional.length;\n        if (length > totalCommands) {\n            throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n        }\n        parsed.demanded.forEach(demanded => {\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, demanded.cmd, position);\n            position += 1;\n        });\n        parsed.optional.forEach(optional => {\n            if (args.length === 0)\n                return;\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, optional.cmd, position);\n            position += 1;\n        });\n    }\n    catch (err) {\n        console.warn(err.stack);\n    }\n}\nfunction guessType(arg) {\n    if (Array.isArray(arg)) {\n        return 'array';\n    }\n    else if (arg === null) {\n        return 'null';\n    }\n    return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n    throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}